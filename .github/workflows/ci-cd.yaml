name: 'CI/CD'

on:
  pull_request:
  push:
    branches:
      - canary
      - main

# GitHub hosted runners are available for Linux x64, Windows x64, and macOS (x64 and arm).
# https://docs.github.com/en/actions/using-github-hosted-runners/using-larger-runners/about-larger-runners#runner-images
# https://github.com/actions/runner-images
# There are other providers that offer ARM runners for Linux (e.g. WarpBuild).
# https://github.com/neysofu/awesome-github-actions-runners#list-of-providers

env:
  GRAALVM_VERSION: 23.0.0
  HEAP_SIZE_AT_BUILD_TIME: '-R:MaxHeapSize=1024m'
  JAVA_VERSION: 21
  OPTIMIZATION_LEVEL: '-O2'
  POD_ID: pod.jackdbd.jsoup
  POD_NAME: pod-jackdbd-jsoup

jobs:
  build-uberjar:
    name: Build uberjar
    runs-on: ubuntu-latest
    # strategy:
    #   matrix:
    #     os: [ubuntu-latest, macOS-latest, windows-latest]
    # runs-on: ${{ matrix.os }}
  
    outputs:
      pod_version: ${{ steps.set_pod_version.outputs.pod_version }}
  
    steps:
      - name: üõéÔ∏è Checkout
        uses: actions/checkout@v4

      # https://github.com/marketplace/actions/github-action-for-graalvm
      - name: üîß Setup GraalVM
        uses: graalvm/setup-graalvm@v1
        with:
          check-for-updates: true
          distribution: graalvm-community
          java-version: ${{ env.JAVA_VERSION }}
          version: ${{ env.GRAALVM_VERSION }}
        
        # It's important to install java before installing clojure tools, because
        # clojure tools needs java exclusions: babashka, clj-kondo and cljstyle.
        # https://github.com/marketplace/actions/setup-clojure
      - name: üîß Setup Clojure tools
        uses: DeLaGuardo/setup-clojure@12.5
        with:
          cli: 'latest' # Clojure CLI based on tools.deps
          bb: 'latest' # Babashka
      
      # https://github.com/actions/cache
      - name: Cache clojure dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.m2/repository
            ~/.gitlibs
            ~/.deps.clj
          # List all files containing dependencies:
          # key: cljdeps-${{ hashFiles('deps.edn') }}
          key: cljdeps-${{ hashFiles('deps.edn', 'bb.edn') }}
          restore-keys: cljdeps-

      - name: Set POD_VERSION (environment variable) and pod_version (job output)
        id: set_pod_version
        run: |
          POD_VERSION=$(bb -e '(-> (slurp "deps.edn") edn/read-string :aliases :neil :project :version)' | tr -d '"')
          echo "POD_VERSION=$POD_VERSION" >> $GITHUB_ENV
          echo "pod_version=$POD_VERSION" >> $GITHUB_OUTPUT
      
      - name: üì¶ Package the pod into an uberjar
        run: clojure -T:build uber
  
      - name: ‚¨ÜÔ∏è Upload uberjar
        uses: actions/upload-artifact@v4
        with:
          name: uberjar
          path: target/${{ env.POD_ID }}-${{ env.POD_VERSION }}-standalone.jar

  linux:
    name: Compile ubuntu-latest-x86_64-binary, Test
    runs-on: ubuntu-latest
    needs: [build-uberjar]

    env:
      POD_VERSION: ${{ needs.build-uberjar.outputs.pod_version }}

    steps:
      - name: üõéÔ∏è Checkout
        uses: actions/checkout@v4

      # https://github.com/marketplace/actions/github-action-for-graalvm
      - name: üîß Setup GraalVM
        uses: graalvm/setup-graalvm@v1
        with:
          check-for-updates: true
          distribution: graalvm-community
          java-version: ${{ env.JAVA_VERSION }}
          native-image-job-reports: true
          native-image-musl: true # Use musl to build a statically compiled binary (Linux only)
          native-image-pr-reports: true
          version: ${{ env.GRAALVM_VERSION }}
          
      # It's important to install java before installing clojure tools, because
      # clojure tools needs java exclusions: babashka, clj-kondo and cljstyle.
      # https://github.com/marketplace/actions/setup-clojure
      - name: üîß Setup Clojure tools
        uses: DeLaGuardo/setup-clojure@12.5
        with:
          cli: 'latest' # Clojure CLI based on tools.deps
          bb: 'latest' # Babashka
    
      - name: Cache clojure dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.m2/repository
            ~/.gitlibs
            ~/.deps.clj
          # List all files containing dependencies:
          # key: cljdeps-${{ hashFiles('deps.edn') }}
          key: cljdeps-${{ hashFiles('deps.edn', 'bb.edn') }}
          restore-keys: cljdeps-

      # This takes ~7 minutes both on my laptop and on GitHub Actions. Maybe look for an alternative.
      # - name: üõ°Ô∏è Audit deps.edn dependencies
      #   run: clojure -M:clj-nvd check

      - name: ‚¨áÔ∏è Download uberjar
        uses: actions/download-artifact@v4
        with:
          name: uberjar

      - name: üì¶ Compile uberjar to x86_64-linux binary with GraalVM native-image
        run: ./script/compile.sh
        env:
          BABASHKA_STATIC: true
          BABASHKA_MUSL: true
      
      # The tests expect the uberjar and the binary to be in a directory called "target"
      - name: Copy the uberjar and the binary to the target directory
        run: |
          mkdir target
          cp ${{ env.POD_ID }}-${{ env.POD_VERSION }}-standalone.jar target/${{ env.POD_ID }}-${{ env.POD_VERSION }}-standalone.jar
          cp ${{ env.POD_ID }}-${{ env.POD_VERSION }}-standalone target/${{ env.POD_NAME }}

      - name: ‚¨ÜÔ∏è Upload the x86_64 Linux binary
        uses: actions/upload-artifact@v4
        with:
          name: ubuntu-latest-x86_64-binary
          path: target/${{ env.POD_NAME }}
        
      - name: üîç Run all tests
        run: clojure -X:test
      
  macos:
    name: Compile macos-latest-aarch64-binary, Test
    runs-on: macOS-latest
    needs: [build-uberjar]

    env:
      POD_VERSION: ${{ needs.build-uberjar.outputs.pod_version }}

    steps:
      - name: üõéÔ∏è Checkout
        uses: actions/checkout@v4
    
      - name: üîß Setup GraalVM
        uses: graalvm/setup-graalvm@v1
        with:
          check-for-updates: true
          distribution: graalvm-community
          java-version: ${{ env.JAVA_VERSION }}
          native-image-job-reports: true
          native-image-pr-reports: true
          version: ${{ env.GRAALVM_VERSION }}

      - name: üîß Setup Clojure tools
        uses: DeLaGuardo/setup-clojure@12.5
        with:
          cli: 'latest'
      
      - name: Cache clojure dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.m2/repository
            ~/.gitlibs
            ~/.deps.clj
          key: cljdeps-${{ hashFiles('deps.edn', 'bb.edn') }}
          restore-keys: cljdeps-

      - name: ‚¨áÔ∏è Download uberjar
        uses: actions/download-artifact@v4
        with:
          name: uberjar

      - name: üì¶ Compile uberjar to AArch64-macOS binary with GraalVM native-image
        # I tried setting -march=x86_64 and the GitHub hosted runner macos-latest
        # gave me this error:
        # On AArch64, only 'ARMV8_A', 'ARMV8_1_A', 'COMPATIBILITY', 'NATIVE' are available.
        run: |
          native-image \
            -jar ${{ env.POD_ID }}-${{ env.POD_VERSION }}-standalone.jar \
            '-H:ReflectionConfigurationFiles=reflection.json' \
            '-H:+ReportExceptionStackTraces' \
            '-J-Dclojure.compiler.direct-linking=true' \
            ${{ env.HEAP_SIZE_AT_BUILD_TIME }} \
            ${{ env.OPTIMIZATION_LEVEL }} \
            '-march=armv8-a' \
            '--initialize-at-build-time' \
            '--native-image-info' \
            '--no-fallback' \
            '--report-unsupported-elements-at-runtime'

      # The tests expect the uberjar and the binary to be in a directory called "target"
      - name: Copy the uberjar and the binary to the target directory
        run: |
          mkdir target
          cp ${{ env.POD_ID }}-${{ env.POD_VERSION }}-standalone.jar target/${{ env.POD_ID }}-${{ env.POD_VERSION }}-standalone.jar
          cp ${{ env.POD_ID }}-${{ env.POD_VERSION }}-standalone target/${{ env.POD_NAME }}

      - name: ‚¨ÜÔ∏è Upload the aarch64 macOS binary
        uses: actions/upload-artifact@v4
        with:
          name: macos-latest-aarch64-binary
          path: target/${{ env.POD_NAME }}

      - name: üîç Run all tests
        run: clojure -X:test      

  windows:
    name: Compile windows-latest-x86_64-binary, Test
    runs-on: windows-latest
    needs: [build-uberjar]

    env:
      POD_VERSION: ${{ needs.build-uberjar.outputs.pod_version }}

    steps:
      - name: üõéÔ∏è Checkout
        uses: actions/checkout@v4

      - name: üîß Setup GraalVM
        uses: graalvm/setup-graalvm@v1
        with:
          check-for-updates: true
          distribution: graalvm-community
          java-version: ${{ env.JAVA_VERSION }}
          native-image-job-reports: true
          native-image-pr-reports: true
          version: ${{ env.GRAALVM_VERSION }}

      - name: üîß Setup Clojure tools
        uses: DeLaGuardo/setup-clojure@12.5
        with:
          cli: 'latest'
      
      - name: Cache clojure dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.m2/repository
            ~/.gitlibs
            ~/.deps.clj
          key: cljdeps-${{ hashFiles('deps.edn', 'bb.edn') }}
          restore-keys: cljdeps-

      - name: ‚¨áÔ∏è Download uberjar
        uses: actions/download-artifact@v4
        with:
          name: uberjar
        
      # See: https://github.com/babashka/pod-babashka-buddy/blob/main/script/compile.bat
      - name: üì¶ Compile uberjar to x86_64-windows binary with GraalVM native-image
        run: >
          native-image
          -jar ${{ env.POD_ID }}-${{ env.POD_VERSION }}-standalone.jar
          '-H:ReflectionConfigurationFiles=reflection.json'
          '-H:+ReportExceptionStackTraces'
          '-J-Dclojure.compiler.direct-linking=true'
          ${{ env.HEAP_SIZE_AT_BUILD_TIME }}
          ${{ env.OPTIMIZATION_LEVEL }}
          '-march=x86-64-v3'
          '--initialize-at-build-time'
          '--native-image-info'
          '--no-fallback'
          '--report-unsupported-elements-at-runtime'

      - name: Copy the uberjar and the binary to the target directory
        run: |
          mkdir target
          move ${{ env.POD_ID }}-${{ env.POD_VERSION }}-standalone.jar target\\${{ env.POD_ID }}-${{ env.POD_VERSION }}-standalone.jar
          move "${{ env.POD_ID }}-${{ env.POD_VERSION }}-standalone.exe" ".\\target\\${{ env.POD_NAME }}.exe"
        shell: cmd

      - name: ‚¨ÜÔ∏è Upload the x86_64 Windows binary
        uses: actions/upload-artifact@v4
        with:
          name: windows-latest-x86_64-binary
          path: ".\\target\\${{ env.POD_NAME }}.exe"

      - name: üîç Run all tests
        run: clojure -X:test

  release:
    name: Release
    if: ${{ github.event_name != 'pull_request' }}
    needs: [build-uberjar, linux, macos, windows]
    concurrency: deploy-group # Ensures that only a single instance of this job is running at any given time.
    runs-on: ubuntu-latest
    
    env:
      POD_VERSION: ${{ needs.build-uberjar.outputs.pod_version }}

    permissions:
      contents: write

    steps:
      - name: üõéÔ∏è Checkout
        uses: actions/checkout@v4

      - name: üîß Setup Clojure tools
        uses: DeLaGuardo/setup-clojure@12.5
        with:
          cli: 'latest'
          bb: 'latest'

      - name: ‚¨áÔ∏è Download uberjar
        uses: actions/download-artifact@v4
        with:
          name: uberjar

      - name: ‚¨áÔ∏è Download x86_64 Linux binary
        uses: actions/download-artifact@v4
        with:
          name: ubuntu-latest-x86_64-binary
          path: ubuntu-latest-x86_64

      - name: ‚¨áÔ∏è Download aarch64 macOS binary
        uses: actions/download-artifact@v4
        with:
          name: macos-latest-aarch64-binary
          path: macos-latest-aarch64

      - name: ‚¨áÔ∏è Download x86_64 Windows binary
        uses: actions/download-artifact@v4
        with:
          name: windows-latest-x86_64-binary
          path: windows-latest-x86_64

      # Troubleshooting: let's see if we have actually downloaded everything
      # - run: ls -R

      - name: üì¶ Create zip archives
        run: |
          pushd . && cd ubuntu-latest-x86_64 && zip "${{ env.POD_NAME }}-${{ env.POD_VERSION }}-ubuntu-latest-x86_64.zip" "pod-jackdbd-jsoup" && popd
          pushd . && cd macos-latest-aarch64 && zip "${{ env.POD_NAME }}-${{ env.POD_VERSION }}-macos-latest-aarch64.zip" "pod-jackdbd-jsoup" && popd
          pushd . && cd windows-latest-x86_64 && zip "${{ env.POD_NAME }}-${{ env.POD_VERSION }}-windows-latest-x86_64.zip" "pod-jackdbd-jsoup.exe" && popd
          mv ubuntu-latest-x86_64/${{ env.POD_NAME }}-${{ env.POD_VERSION }}-ubuntu-latest-x86_64.zip .
          mv macos-latest-aarch64/${{ env.POD_NAME }}-${{ env.POD_VERSION }}-macos-latest-aarch64.zip .
          mv windows-latest-x86_64/${{ env.POD_NAME }}-${{ env.POD_VERSION }}-windows-latest-x86_64.zip .

      # Troubleshooting: let's see if we have actually created all zip archives and moved them to the correct place
      - run: ls -R

      # https://github.com/marketplace/actions/gh-release
      - name: üöÄ Create GitHub release
        uses: softprops/action-gh-release@v2
        with:
          body: |
            This is a release of ${{ env.POD_NAME }} version ${{ env.POD_VERSION }}.
          draft: true
          # TODO: add to files: CHANGELOG.md manifest.edn jar? uberjar? pom.xml?
          files: |
            LICENSE
            ${{ env.POD_ID }}-${{ env.POD_VERSION }}-standalone.jar
            ${{ env.POD_NAME }}-${{ env.POD_VERSION }}-ubuntu-latest-x86_64.zip
            ${{ env.POD_NAME }}-${{ env.POD_VERSION }}-macos-latest-aarch64.zip
            ${{ env.POD_NAME }}-${{ env.POD_VERSION }}-windows-latest-x86_64.zip

      - name: üìÑ Write manifest.edn for Babashka pod registry (TODO)
        run: bb manifest.edn

      - name: üì¶ Package the pod into a jar
        run: clojure -T:build jar :snapshot false

      # TODO: maybe create a snapshot release when the branch is not main (e.g. canary)
      - name: üåê Publish the jar to Clojars
        env:
          CLOJARS_USERNAME: jackdbd
          CLOJARS_PASSWORD: ${{ secrets.CLOJARS_PASSWORD }}
        run: clojure -T:build deploy :snapshot false
